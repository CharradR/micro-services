{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let KeycloakService = /*#__PURE__*/(() => {\n  class KeycloakService {\n    constructor(http) {\n      this.http = http;\n      this.config = {\n        url: 'http://localhost:8080',\n        realm: 'LibraryKeyClock',\n        clientId: 'frontend-client' // Update this to match your client\n      };\n\n      this.tokenSubject = new BehaviorSubject(null);\n      this.userProfileSubject = new BehaviorSubject(null);\n      this.isAuthenticatedSubject = new BehaviorSubject(false);\n      this.token$ = this.tokenSubject.asObservable();\n      this.userProfile$ = this.userProfileSubject.asObservable();\n      this.isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n      this.loadTokenFromStorage();\n      this.handleAuthCallback();\n    }\n    /**\r\n     * Initialize the service and check for existing tokens or auth callback\r\n     */\n    init() {\n      // Check if we're returning from Keycloak with auth code\n      if (this.isAuthCallback()) {\n        this.handleAuthCallback();\n        return;\n      }\n      const token = this.getToken();\n      if (token && !this.isTokenExpired(token)) {\n        this.setToken(token);\n        this.loadUserProfile();\n      } else {\n        this.clearToken();\n      }\n    }\n    /**\r\n     * Redirect to Keycloak login page (OAuth2/OIDC flow)\r\n     */\n    login() {\n      const state = this.generateRandomString(32);\n      const nonce = this.generateRandomString(32);\n      // Store state and nonce for security validation\n      sessionStorage.setItem('oauth_state', state);\n      sessionStorage.setItem('oauth_nonce', nonce);\n      sessionStorage.setItem('return_url', window.location.href);\n      const authUrl = this.buildAuthUrl(state, nonce);\n      console.log('Redirecting to Keycloak login:', authUrl);\n      window.location.href = authUrl;\n    }\n    /**\r\n     * Build authorization URL for OAuth2/OIDC flow\r\n     */\n    buildAuthUrl(state, nonce) {\n      const params = new URLSearchParams({\n        'client_id': this.config.clientId,\n        'redirect_uri': this.getRedirectUri(),\n        'state': state,\n        'nonce': nonce,\n        'response_type': 'code',\n        'scope': 'openid profile email',\n        'response_mode': 'query'\n      });\n      return `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/auth?${params.toString()}`;\n    }\n    /**\r\n     * Get redirect URI for OAuth2 callback\r\n     */\n    getRedirectUri() {\n      const currentUrl = window.location.origin + window.location.pathname;\n      return currentUrl;\n    }\n    /**\r\n     * Check if current URL is an OAuth2 callback\r\n     */\n    isAuthCallback() {\n      const urlParams = new URLSearchParams(window.location.search);\n      return urlParams.has('code') && urlParams.has('state');\n    }\n    /**\r\n     * Handle OAuth2 callback and exchange code for tokens\r\n     */\n    handleAuthCallback() {\n      if (!this.isAuthCallback()) {\n        return;\n      }\n      const urlParams = new URLSearchParams(window.location.search);\n      const code = urlParams.get('code');\n      const state = urlParams.get('state');\n      const storedState = sessionStorage.getItem('oauth_state');\n      // Validate state parameter for security\n      if (!state || state !== storedState) {\n        console.error('Invalid state parameter in OAuth callback');\n        this.clearToken();\n        return;\n      }\n      if (code) {\n        this.exchangeCodeForTokens(code).subscribe({\n          next: success => {\n            if (success) {\n              // Clean up URL and redirect to original page\n              this.cleanupAuthCallback();\n              this.redirectToOriginalPage();\n            } else {\n              console.error('Failed to exchange code for tokens');\n              this.clearToken();\n            }\n          },\n          error: error => {\n            console.error('Error during token exchange:', error);\n            this.clearToken();\n          }\n        });\n      }\n    }\n    /**\r\n     * Exchange authorization code for access tokens\r\n     */\n    exchangeCodeForTokens(code) {\n      const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n      const body = new URLSearchParams();\n      body.set('grant_type', 'authorization_code');\n      body.set('client_id', this.config.clientId);\n      body.set('code', code);\n      body.set('redirect_uri', this.getRedirectUri());\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      return this.http.post(tokenUrl, body.toString(), {\n        headers\n      }).pipe(map(response => {\n        this.setToken(response.access_token);\n        this.setRefreshToken(response.refresh_token);\n        this.loadUserProfile();\n        return true;\n      }), catchError(error => {\n        console.error('Token exchange failed:', error);\n        return of(false);\n      }));\n    }\n    /**\r\n     * Clean up OAuth callback parameters from URL\r\n     */\n    cleanupAuthCallback() {\n      const url = new URL(window.location.href);\n      url.searchParams.delete('code');\n      url.searchParams.delete('state');\n      url.searchParams.delete('session_state');\n      // Update URL without refreshing the page\n      window.history.replaceState({}, document.title, url.toString());\n      // Clean up session storage\n      sessionStorage.removeItem('oauth_state');\n      sessionStorage.removeItem('oauth_nonce');\n    }\n    /**\r\n     * Redirect to original page after authentication\r\n     */\n    redirectToOriginalPage() {\n      const returnUrl = sessionStorage.getItem('return_url');\n      sessionStorage.removeItem('return_url');\n      if (returnUrl && returnUrl !== window.location.href) {\n        window.location.href = returnUrl;\n      }\n    }\n    /**\r\n     * Generate random string for state/nonce parameters\r\n     */\n    generateRandomString(length) {\n      const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n      let result = '';\n      for (let i = 0; i < length; i++) {\n        result += charset.charAt(Math.floor(Math.random() * charset.length));\n      }\n      return result;\n    }\n    /**\r\n     * Logout the user\r\n     */\n    logout() {\n      const logoutUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/logout`;\n      const refreshToken = this.getRefreshToken();\n      if (!refreshToken) {\n        this.clearToken();\n        return of(true);\n      }\n      const body = new URLSearchParams();\n      body.set('client_id', this.config.clientId);\n      body.set('refresh_token', refreshToken);\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      return this.http.post(logoutUrl, body.toString(), {\n        headers\n      }).pipe(map(() => {\n        this.clearToken();\n        return true;\n      }), catchError(error => {\n        console.error('Logout failed:', error);\n        this.clearToken(); // Clear token anyway\n        return of(true);\n      }));\n    }\n    /**\r\n     * Refresh the access token\r\n     */\n    refreshToken() {\n      const refreshToken = this.getRefreshToken();\n      if (!refreshToken) {\n        return of(false);\n      }\n      const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n      const body = new URLSearchParams();\n      body.set('grant_type', 'refresh_token');\n      body.set('client_id', this.config.clientId);\n      body.set('refresh_token', refreshToken);\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      return this.http.post(tokenUrl, body.toString(), {\n        headers\n      }).pipe(map(response => {\n        this.setToken(response.access_token);\n        this.setRefreshToken(response.refresh_token);\n        return true;\n      }), catchError(error => {\n        console.error('Token refresh failed:', error);\n        this.clearToken();\n        return of(false);\n      }));\n    }\n    /**\r\n     * Get the current access token\r\n     */\n    getToken() {\n      return localStorage.getItem('access_token');\n    }\n    /**\r\n     * Get the current refresh token\r\n     */\n    getRefreshToken() {\n      return localStorage.getItem('refresh_token');\n    }\n    /**\r\n     * Check if user is authenticated\r\n     */\n    isAuthenticated() {\n      const token = this.getToken();\n      return token !== null && !this.isTokenExpired(token);\n    }\n    /**\r\n     * Check if token is expired\r\n     */\n    isTokenExpired(token) {\n      try {\n        const payload = JSON.parse(atob(token.split('.')[1]));\n        const now = Math.floor(Date.now() / 1000);\n        return payload.exp < now;\n      } catch (error) {\n        return true;\n      }\n    }\n    /**\r\n     * Get user roles from token\r\n     */\n    getUserRoles() {\n      const token = this.getToken();\n      if (!token) return [];\n      try {\n        const payload = JSON.parse(atob(token.split('.')[1]));\n        return payload.realm_access?.roles || [];\n      } catch (error) {\n        return [];\n      }\n    }\n    /**\r\n     * Check if user has specific role\r\n     */\n    hasRole(role) {\n      return this.getUserRoles().includes(role);\n    }\n    /**\r\n     * Get user profile\r\n     */\n    getUserProfile() {\n      return this.userProfileSubject.value;\n    }\n    /**\r\n     * Load user profile from Keycloak\r\n     */\n    loadUserProfile() {\n      const userInfoUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/userinfo`;\n      const headers = new HttpHeaders({\n        'Authorization': `Bearer ${this.getToken()}`\n      });\n      this.http.get(userInfoUrl, {\n        headers\n      }).pipe(map(profile => {\n        const roles = this.getUserRoles();\n        const userProfile = {\n          ...profile,\n          roles\n        };\n        this.userProfileSubject.next(userProfile);\n        return userProfile;\n      }), catchError(error => {\n        console.error('Failed to load user profile:', error);\n        return of(null);\n      })).subscribe();\n    }\n    /**\r\n     * Set the access token\r\n     */\n    setToken(token) {\n      localStorage.setItem('access_token', token);\n      this.tokenSubject.next(token);\n      this.isAuthenticatedSubject.next(true);\n    }\n    /**\r\n     * Set the refresh token\r\n     */\n    setRefreshToken(token) {\n      localStorage.setItem('refresh_token', token);\n    }\n    /**\r\n     * Clear all tokens and user data\r\n     */\n    clearToken() {\n      localStorage.removeItem('access_token');\n      localStorage.removeItem('refresh_token');\n      this.tokenSubject.next(null);\n      this.userProfileSubject.next(null);\n      this.isAuthenticatedSubject.next(false);\n    }\n    /**\r\n     * Load token from storage on service initialization\r\n     */\n    loadTokenFromStorage() {\n      const token = this.getToken();\n      if (token && !this.isTokenExpired(token)) {\n        this.tokenSubject.next(token);\n        this.isAuthenticatedSubject.next(true);\n      }\n    }\n    static {\n      this.ɵfac = function KeycloakService_Factory(t) {\n        return new (t || KeycloakService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: KeycloakService,\n        factory: KeycloakService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return KeycloakService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}