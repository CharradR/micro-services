{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class KeycloakService {\n  constructor(http) {\n    this.http = http;\n    this.config = {\n      url: 'http://localhost:8080',\n      realm: 'LibraryKeyClock',\n      clientId: 'frontend-client' // Update this to match your client\n    };\n\n    this.tokenSubject = new BehaviorSubject(null);\n    this.userProfileSubject = new BehaviorSubject(null);\n    this.isAuthenticatedSubject = new BehaviorSubject(false);\n    this.token$ = this.tokenSubject.asObservable();\n    this.userProfile$ = this.userProfileSubject.asObservable();\n    this.isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n    this.loadTokenFromStorage();\n    this.handleAuthCallback();\n  }\n  /**\r\n   * Initialize the service and check for existing tokens or auth callback\r\n   */\n  init() {\n    // Check if we're returning from Keycloak with auth code\n    if (this.isAuthCallback()) {\n      this.handleAuthCallback();\n      return;\n    }\n    const token = this.getToken();\n    if (token && !this.isTokenExpired(token)) {\n      this.setToken(token);\n      this.loadUserProfile();\n    } else {\n      this.clearToken();\n    }\n  }\n  /**\r\n   * Redirect to Keycloak login page (OAuth2/OIDC flow)\r\n   */\n  login() {\n    const state = this.generateRandomString(32);\n    const nonce = this.generateRandomString(32);\n    // Store state and nonce for security validation\n    sessionStorage.setItem('oauth_state', state);\n    sessionStorage.setItem('oauth_nonce', nonce);\n    sessionStorage.setItem('return_url', window.location.href);\n    const authUrl = this.buildAuthUrl(state, nonce);\n    console.log('Redirecting to Keycloak login:', authUrl);\n    window.location.href = authUrl;\n  }\n  /**\r\n   * Build authorization URL for OAuth2/OIDC flow\r\n   */\n  buildAuthUrl(state, nonce) {\n    const params = new URLSearchParams({\n      'client_id': this.config.clientId,\n      'redirect_uri': this.getRedirectUri(),\n      'state': state,\n      'nonce': nonce,\n      'response_type': 'code',\n      'scope': 'openid profile email',\n      'response_mode': 'query'\n    });\n    return `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/auth?${params.toString()}`;\n  }\n  /**\r\n   * Get redirect URI for OAuth2 callback\r\n   */\n  getRedirectUri() {\n    const currentUrl = window.location.origin + window.location.pathname;\n    return currentUrl;\n  }\n  /**\r\n   * Check if current URL is an OAuth2 callback\r\n   */\n  isAuthCallback() {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.has('code') && urlParams.has('state');\n  }\n  /**\r\n   * Handle OAuth2 callback and exchange code for tokens\r\n   */\n  handleAuthCallback() {\n    if (!this.isAuthCallback()) {\n      return;\n    }\n    const urlParams = new URLSearchParams(window.location.search);\n    const code = urlParams.get('code');\n    const state = urlParams.get('state');\n    const storedState = sessionStorage.getItem('oauth_state');\n    // Validate state parameter for security\n    if (!state || state !== storedState) {\n      console.error('Invalid state parameter in OAuth callback');\n      this.clearToken();\n      return;\n    }\n    if (code) {\n      this.exchangeCodeForTokens(code).subscribe({\n        next: success => {\n          if (success) {\n            // Clean up URL and redirect to original page\n            this.cleanupAuthCallback();\n            this.redirectToOriginalPage();\n          } else {\n            console.error('Failed to exchange code for tokens');\n            this.clearToken();\n          }\n        },\n        error: error => {\n          console.error('Error during token exchange:', error);\n          this.clearToken();\n        }\n      });\n    }\n  }\n  /**\r\n   * Exchange authorization code for access tokens\r\n   */\n  exchangeCodeForTokens(code) {\n    const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n    const body = new URLSearchParams();\n    body.set('grant_type', 'authorization_code');\n    body.set('client_id', this.config.clientId);\n    body.set('code', code);\n    body.set('redirect_uri', this.getRedirectUri());\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n    return this.http.post(tokenUrl, body.toString(), {\n      headers\n    }).pipe(map(response => {\n      this.setToken(response.access_token);\n      this.setRefreshToken(response.refresh_token);\n      this.loadUserProfile();\n      return true;\n    }), catchError(error => {\n      console.error('Token exchange failed:', error);\n      return of(false);\n    }));\n  }\n  /**\r\n   * Clean up OAuth callback parameters from URL\r\n   */\n  cleanupAuthCallback() {\n    const url = new URL(window.location.href);\n    url.searchParams.delete('code');\n    url.searchParams.delete('state');\n    url.searchParams.delete('session_state');\n    // Update URL without refreshing the page\n    window.history.replaceState({}, document.title, url.toString());\n    // Clean up session storage\n    sessionStorage.removeItem('oauth_state');\n    sessionStorage.removeItem('oauth_nonce');\n  }\n  /**\r\n   * Redirect to original page after authentication\r\n   */\n  redirectToOriginalPage() {\n    const returnUrl = sessionStorage.getItem('return_url');\n    sessionStorage.removeItem('return_url');\n    if (returnUrl && returnUrl !== window.location.href) {\n      window.location.href = returnUrl;\n    }\n  }\n  /**\r\n   * Generate random string for state/nonce parameters\r\n   */\n  generateRandomString(length) {\n    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += charset.charAt(Math.floor(Math.random() * charset.length));\n    }\n    return result;\n  }\n  /**\r\n   * Logout the user\r\n   */\n  logout() {\n    const logoutUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/logout`;\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      this.clearToken();\n      return of(true);\n    }\n    const body = new URLSearchParams();\n    body.set('client_id', this.config.clientId);\n    body.set('refresh_token', refreshToken);\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n    return this.http.post(logoutUrl, body.toString(), {\n      headers\n    }).pipe(map(() => {\n      this.clearToken();\n      return true;\n    }), catchError(error => {\n      console.error('Logout failed:', error);\n      this.clearToken(); // Clear token anyway\n      return of(true);\n    }));\n  }\n  /**\r\n   * Refresh the access token\r\n   */\n  refreshToken() {\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      return of(false);\n    }\n    const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n    const body = new URLSearchParams();\n    body.set('grant_type', 'refresh_token');\n    body.set('client_id', this.config.clientId);\n    body.set('refresh_token', refreshToken);\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n    return this.http.post(tokenUrl, body.toString(), {\n      headers\n    }).pipe(map(response => {\n      this.setToken(response.access_token);\n      this.setRefreshToken(response.refresh_token);\n      return true;\n    }), catchError(error => {\n      console.error('Token refresh failed:', error);\n      this.clearToken();\n      return of(false);\n    }));\n  }\n  /**\r\n   * Get the current access token\r\n   */\n  getToken() {\n    return localStorage.getItem('access_token');\n  }\n  /**\r\n   * Get the current refresh token\r\n   */\n  getRefreshToken() {\n    return localStorage.getItem('refresh_token');\n  }\n  /**\r\n   * Check if user is authenticated\r\n   */\n  isAuthenticated() {\n    const token = this.getToken();\n    return token !== null && !this.isTokenExpired(token);\n  }\n  /**\r\n   * Check if token is expired\r\n   */\n  isTokenExpired(token) {\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp < now;\n    } catch (error) {\n      return true;\n    }\n  }\n  /**\r\n   * Get user roles from token\r\n   */\n  getUserRoles() {\n    const token = this.getToken();\n    if (!token) return [];\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return payload.realm_access?.roles || [];\n    } catch (error) {\n      return [];\n    }\n  }\n  /**\r\n   * Check if user has specific role\r\n   */\n  hasRole(role) {\n    return this.getUserRoles().includes(role);\n  }\n  /**\r\n   * Get user profile\r\n   */\n  getUserProfile() {\n    return this.userProfileSubject.value;\n  }\n  /**\r\n   * Load user profile from Keycloak\r\n   */\n  loadUserProfile() {\n    const userInfoUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/userinfo`;\n    const headers = new HttpHeaders({\n      'Authorization': `Bearer ${this.getToken()}`\n    });\n    this.http.get(userInfoUrl, {\n      headers\n    }).pipe(map(profile => {\n      const roles = this.getUserRoles();\n      const userProfile = {\n        ...profile,\n        roles\n      };\n      this.userProfileSubject.next(userProfile);\n      return userProfile;\n    }), catchError(error => {\n      console.error('Failed to load user profile:', error);\n      return of(null);\n    })).subscribe();\n  }\n  /**\r\n   * Set the access token\r\n   */\n  setToken(token) {\n    localStorage.setItem('access_token', token);\n    this.tokenSubject.next(token);\n    this.isAuthenticatedSubject.next(true);\n  }\n  /**\r\n   * Set the refresh token\r\n   */\n  setRefreshToken(token) {\n    localStorage.setItem('refresh_token', token);\n  }\n  /**\r\n   * Clear all tokens and user data\r\n   */\n  clearToken() {\n    localStorage.removeItem('access_token');\n    localStorage.removeItem('refresh_token');\n    this.tokenSubject.next(null);\n    this.userProfileSubject.next(null);\n    this.isAuthenticatedSubject.next(false);\n  }\n  /**\r\n   * Load token from storage on service initialization\r\n   */\n  loadTokenFromStorage() {\n    const token = this.getToken();\n    if (token && !this.isTokenExpired(token)) {\n      this.tokenSubject.next(token);\n      this.isAuthenticatedSubject.next(true);\n    }\n  }\n  static {\n    this.ɵfac = function KeycloakService_Factory(t) {\n      return new (t || KeycloakService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: KeycloakService,\n      factory: KeycloakService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpHeaders","BehaviorSubject","map","catchError","of","KeycloakService","constructor","http","url","realm","clientId","tokenSubject","asObservable","userProfileSubject","isAuthenticatedSubject","loadTokenFromStorage","handleAuthCallback","init","isAuthCallback","token","getToken","isTokenExpired","setToken","loadUserProfile","clearToken","login","state","generateRandomString","nonce","sessionStorage","setItem","window","location","href","authUrl","buildAuthUrl","console","log","params","URLSearchParams","config","getRedirectUri","toString","currentUrl","origin","pathname","urlParams","search","has","code","get","storedState","getItem","error","exchangeCodeForTokens","subscribe","next","success","cleanupAuthCallback","redirectToOriginalPage","tokenUrl","body","set","headers","post","pipe","response","access_token","setRefreshToken","refresh_token","URL","searchParams","delete","history","replaceState","document","title","removeItem","returnUrl","length","charset","result","i","charAt","Math","floor","random","logout","logoutUrl","refreshToken","getRefreshToken","localStorage","isAuthenticated","payload","JSON","parse","atob","split","now","Date","exp","getUserRoles","realm_access","roles","hasRole","role","includes","getUserProfile","value","userInfoUrl","profile","userProfile","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\donia\\Desktop\\micro-services\\educationProject\\src\\app\\services\\keycloak.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Observable, BehaviorSubject } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { of } from 'rxjs';\n\nexport interface KeycloakConfig {\n  url: string;\n  realm: string;\n  clientId: string;\n}\n\nexport interface TokenResponse {\n  access_token: string;\n  refresh_token: string;\n  token_type: string;\n  expires_in: number;\n}\n\nexport interface UserProfile {\n  sub: string;\n  name: string;\n  given_name: string;\n  family_name: string;\n  preferred_username: string;\n  email: string;\n  email_verified: boolean;\n  roles: string[];\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class KeycloakService {\n  private config: KeycloakConfig = {\n    url: 'http://localhost:8080',\n    realm: 'LibraryKeyClock', // Update this to match your realm\n    clientId: 'frontend-client' // Update this to match your client\n  };\n\n  private tokenSubject = new BehaviorSubject<string | null>(null);\n  private userProfileSubject = new BehaviorSubject<UserProfile | null>(null);\n  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);\n\n  public token$ = this.tokenSubject.asObservable();\n  public userProfile$ = this.userProfileSubject.asObservable();\n  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n\n  constructor(private http: HttpClient) {\n    this.loadTokenFromStorage();\n    this.handleAuthCallback();\n  }\n\n  /**\n   * Initialize the service and check for existing tokens or auth callback\n   */\n  init(): void {\n    // Check if we're returning from Keycloak with auth code\n    if (this.isAuthCallback()) {\n      this.handleAuthCallback();\n      return;\n    }\n\n    const token = this.getToken();\n    if (token && !this.isTokenExpired(token)) {\n      this.setToken(token);\n      this.loadUserProfile();\n    } else {\n      this.clearToken();\n    }\n  }\n\n  /**\n   * Redirect to Keycloak login page (OAuth2/OIDC flow)\n   */\n  login(): void {\n    const state = this.generateRandomString(32);\n    const nonce = this.generateRandomString(32);\n    \n    // Store state and nonce for security validation\n    sessionStorage.setItem('oauth_state', state);\n    sessionStorage.setItem('oauth_nonce', nonce);\n    sessionStorage.setItem('return_url', window.location.href);\n\n    const authUrl = this.buildAuthUrl(state, nonce);\n    \n    console.log('Redirecting to Keycloak login:', authUrl);\n    window.location.href = authUrl;\n  }\n\n  /**\n   * Build authorization URL for OAuth2/OIDC flow\n   */\n  private buildAuthUrl(state: string, nonce: string): string {\n    const params = new URLSearchParams({\n      'client_id': this.config.clientId,\n      'redirect_uri': this.getRedirectUri(),\n      'state': state,\n      'nonce': nonce,\n      'response_type': 'code',\n      'scope': 'openid profile email',\n      'response_mode': 'query'\n    });\n\n    return `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/auth?${params.toString()}`;\n  }\n\n  /**\n   * Get redirect URI for OAuth2 callback\n   */\n  private getRedirectUri(): string {\n    const currentUrl = window.location.origin + window.location.pathname;\n    return currentUrl;\n  }\n\n  /**\n   * Check if current URL is an OAuth2 callback\n   */\n  private isAuthCallback(): boolean {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.has('code') && urlParams.has('state');\n  }\n\n  /**\n   * Handle OAuth2 callback and exchange code for tokens\n   */\n  private handleAuthCallback(): void {\n    if (!this.isAuthCallback()) {\n      return;\n    }\n\n    const urlParams = new URLSearchParams(window.location.search);\n    const code = urlParams.get('code');\n    const state = urlParams.get('state');\n    const storedState = sessionStorage.getItem('oauth_state');\n\n    // Validate state parameter for security\n    if (!state || state !== storedState) {\n      console.error('Invalid state parameter in OAuth callback');\n      this.clearToken();\n      return;\n    }\n\n    if (code) {\n      this.exchangeCodeForTokens(code).subscribe({\n        next: (success) => {\n          if (success) {\n            // Clean up URL and redirect to original page\n            this.cleanupAuthCallback();\n            this.redirectToOriginalPage();\n          } else {\n            console.error('Failed to exchange code for tokens');\n            this.clearToken();\n          }\n        },\n        error: (error) => {\n          console.error('Error during token exchange:', error);\n          this.clearToken();\n        }\n      });\n    }\n  }\n\n  /**\n   * Exchange authorization code for access tokens\n   */\n  private exchangeCodeForTokens(code: string): Observable<boolean> {\n    const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n    \n    const body = new URLSearchParams();\n    body.set('grant_type', 'authorization_code');\n    body.set('client_id', this.config.clientId);\n    body.set('code', code);\n    body.set('redirect_uri', this.getRedirectUri());\n\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n\n    return this.http.post<TokenResponse>(tokenUrl, body.toString(), { headers }).pipe(\n      map(response => {\n        this.setToken(response.access_token);\n        this.setRefreshToken(response.refresh_token);\n        this.loadUserProfile();\n        return true;\n      }),\n      catchError(error => {\n        console.error('Token exchange failed:', error);\n        return of(false);\n      })\n    );\n  }\n\n  /**\n   * Clean up OAuth callback parameters from URL\n   */\n  private cleanupAuthCallback(): void {\n    const url = new URL(window.location.href);\n    url.searchParams.delete('code');\n    url.searchParams.delete('state');\n    url.searchParams.delete('session_state');\n    \n    // Update URL without refreshing the page\n    window.history.replaceState({}, document.title, url.toString());\n    \n    // Clean up session storage\n    sessionStorage.removeItem('oauth_state');\n    sessionStorage.removeItem('oauth_nonce');\n  }\n\n  /**\n   * Redirect to original page after authentication\n   */\n  private redirectToOriginalPage(): void {\n    const returnUrl = sessionStorage.getItem('return_url');\n    sessionStorage.removeItem('return_url');\n    \n    if (returnUrl && returnUrl !== window.location.href) {\n      window.location.href = returnUrl;\n    }\n  }\n\n  /**\n   * Generate random string for state/nonce parameters\n   */\n  private generateRandomString(length: number): string {\n    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += charset.charAt(Math.floor(Math.random() * charset.length));\n    }\n    return result;\n  }\n\n  /**\n   * Logout the user\n   */\n  logout(): Observable<boolean> {\n    const logoutUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/logout`;\n    \n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      this.clearToken();\n      return of(true);\n    }\n\n    const body = new URLSearchParams();\n    body.set('client_id', this.config.clientId);\n    body.set('refresh_token', refreshToken);\n\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n\n    return this.http.post(logoutUrl, body.toString(), { headers }).pipe(\n      map(() => {\n        this.clearToken();\n        return true;\n      }),\n      catchError(error => {\n        console.error('Logout failed:', error);\n        this.clearToken(); // Clear token anyway\n        return of(true);\n      })\n    );\n  }\n\n  /**\n   * Refresh the access token\n   */\n  refreshToken(): Observable<boolean> {\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      return of(false);\n    }\n\n    const tokenUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/token`;\n    \n    const body = new URLSearchParams();\n    body.set('grant_type', 'refresh_token');\n    body.set('client_id', this.config.clientId);\n    body.set('refresh_token', refreshToken);\n\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    });\n\n    return this.http.post<TokenResponse>(tokenUrl, body.toString(), { headers }).pipe(\n      map(response => {\n        this.setToken(response.access_token);\n        this.setRefreshToken(response.refresh_token);\n        return true;\n      }),\n      catchError(error => {\n        console.error('Token refresh failed:', error);\n        this.clearToken();\n        return of(false);\n      })\n    );\n  }\n\n  /**\n   * Get the current access token\n   */\n  getToken(): string | null {\n    return localStorage.getItem('access_token');\n  }\n\n  /**\n   * Get the current refresh token\n   */\n  getRefreshToken(): string | null {\n    return localStorage.getItem('refresh_token');\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    const token = this.getToken();\n    return token !== null && !this.isTokenExpired(token);\n  }\n\n  /**\n   * Check if token is expired\n   */\n  isTokenExpired(token: string): boolean {\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp < now;\n    } catch (error) {\n      return true;\n    }\n  }\n\n  /**\n   * Get user roles from token\n   */\n  getUserRoles(): string[] {\n    const token = this.getToken();\n    if (!token) return [];\n\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return payload.realm_access?.roles || [];\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Check if user has specific role\n   */\n  hasRole(role: string): boolean {\n    return this.getUserRoles().includes(role);\n  }\n\n  /**\n   * Get user profile\n   */\n  getUserProfile(): UserProfile | null {\n    return this.userProfileSubject.value;\n  }\n\n  /**\n   * Load user profile from Keycloak\n   */\n  private loadUserProfile(): void {\n    const userInfoUrl = `${this.config.url}/realms/${this.config.realm}/protocol/openid-connect/userinfo`;\n    \n    const headers = new HttpHeaders({\n      'Authorization': `Bearer ${this.getToken()}`\n    });\n\n    this.http.get<UserProfile>(userInfoUrl, { headers }).pipe(\n      map(profile => {\n        const roles = this.getUserRoles();\n        const userProfile: UserProfile = { ...profile, roles };\n        this.userProfileSubject.next(userProfile);\n        return userProfile;\n      }),\n      catchError(error => {\n        console.error('Failed to load user profile:', error);\n        return of(null);\n      })\n    ).subscribe();\n  }\n\n  /**\n   * Set the access token\n   */\n  private setToken(token: string): void {\n    localStorage.setItem('access_token', token);\n    this.tokenSubject.next(token);\n    this.isAuthenticatedSubject.next(true);\n  }\n\n  /**\n   * Set the refresh token\n   */\n  private setRefreshToken(token: string): void {\n    localStorage.setItem('refresh_token', token);\n  }\n\n  /**\n   * Clear all tokens and user data\n   */\n  private clearToken(): void {\n    localStorage.removeItem('access_token');\n    localStorage.removeItem('refresh_token');\n    this.tokenSubject.next(null);\n    this.userProfileSubject.next(null);\n    this.isAuthenticatedSubject.next(false);\n  }\n\n  /**\n   * Load token from storage on service initialization\n   */\n  private loadTokenFromStorage(): void {\n    const token = this.getToken();\n    if (token && !this.isTokenExpired(token)) {\n      this.tokenSubject.next(token);\n      this.isAuthenticatedSubject.next(true);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}